#include "Scanner.h"
#include "include/fuzzy.h"

Scanner::Scanner()
{
    cout << "Starting a malware scanner." << endl;
    // Signature of https://github.com/orenjp/ReverseShell_Windows
    vSigs.push_back("384:jNRChmQMm72TmaRck28lW5CbbEqfxBkS/b:jNRPQbYmaRzlkqfvkA");
    vExtensions.push_back("txt");
    vExtensions.push_back("docx");
    vExtensions.push_back("pdf");

}

BOOL Scanner::ScanFile(LPCSTR fileName, BOOL deleteFlag) {
    //Extract the file extension
    const char* extension = fileName;
    for (int i = 0; i < strlen(fileName); i++) {
        if (fileName[i] == '.') {
            extension = fileName + i + 1;
            break;
        }
    }

    // Don't scan if extension in exclude vector
    for (size_t i = 0; i < vExtensions.size(); i++) {
        if (strcmp(extension, vExtensions[i]) == 0)
            return FALSE;
    }
    HANDLE hFile = CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE; //Cannot open file

    // Get file size, proceed if under 10MB
    DWORD fileSize = GetFileSize(hFile, NULL);
    if (fileSize > 1048576) {
        CloseHandle(hFile);
        return FALSE;
    }
    CloseHandle(hFile);

    //Calculate hash using FUZZY HASHING API
    char* fileHash = new char[FUZZY_MAX_RESULT];
    fuzzy_hash_filename(fileName, fileHash);

    // Compare the result with the known signatures
    for (size_t i=0; i< vSigs.size(); i++)
    {
        if (strcmp(fileHash, vSigs[i]) == 0)
        {
            cout << fileName << " : " << fileHash << endl;
            MessageBox(NULL, fileName, "Found malware", MB_OK | MB_ICONWARNING);
            // Delete the file if flag is set
            if (deleteFlag) DeleteFile(fileName);

            return TRUE;
        }
    }
    return FALSE;
}

void Scanner::ScanDirectory(LPCSTR dirName)
{
    WIN32_FIND_DATA fileData;
    HANDLE hFind;

    char dir[MAX_PATH];			 // Directory name with backslash
    char dirWildcat[MAX_PATH];   // Directory name with wildcat to list all files
    vector<char*> vDirectories; // Store all sub-directories for recurisve scan

    // dirName represents a file - scan it
    if (!(GetFileAttributes(dirName) & FILE_ATTRIBUTE_DIRECTORY)) {
        //ScanFile(lpFolderName, TRUE);
        cout << "A file." << endl;
        return;
    }

    // Add backslash at end if necessary
    strcpy(dir, dirName);
    if (dir[strlen(dir) - 1] != '\\')
        strcat(dir, "\\");
    // Add wildcat
    strcpy(dirWildcat, dir);
    strcat(dirWildcat, "*");

    hFind = FindFirstFile(dirWildcat, &fileData);
    if (hFind == INVALID_HANDLE_VALUE)
        return;

    do {
        // Get new path length
        int pathLen = strlen(dir) + strlen(fileData.cFileName) + 1;
        char* newFile = new char[pathLen];

        // Create path to new file
        strcpy(newFile, dir);
        strcat(newFile, fileData.cFileName);

        // If it is a directory, add to directories' vector
        if (fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            // Avoid links
            if (strcmp(fileData.cFileName, ".") != 0 &&
                strcmp(fileData.cFileName, "..") != 0)
            {
                // Add new directory to vector, to scan it later
                vDirectories.push_back(newFile);
            }
        }
        else // A file
        {
            // Scan this file
            ScanFile(newFile, TRUE);
            // Free the string
            delete[] newFile;
        }
    } while (FindNextFile(hFind, &fileData) != 0);

    //Finished scanning current directory
    FindClose(hFind);

    //Iterate over sub-directories
    for (size_t i = 0; i < vDirectories.size(); i++)
    {
        if (vDirectories[i] != NULL) {
            ScanDirectory(vDirectories[i]);
            delete[] vDirectories[i]; // Free the allocated string
        }
    }
}
void Scanner::CheckProcess(DWORD processID) {
    HANDLE processHandle = NULL;
    char fileName[MAX_PATH];
    processHandle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_TERMINATE, FALSE, processID);
    if (processHandle != NULL) {
        if (GetModuleFileNameEx(processHandle, NULL, fileName, MAX_PATH)) {
            if (ScanFile(fileName, FALSE)) {  //Check if suspicious file
                // Terminate process first so we can delete the file
                TerminateProcess(processHandle, 0);
                Sleep(1000);
                DeleteFile(fileName);
            }
        }
        CloseHandle(processHandle);
    }
}
void Scanner::ScanProcesses() {
    DWORD aProcesses[1024], cbNeeded, cProcesses; // cbNeeded will hold the number of bytes returned
    // Enumerate running processes
    if (!EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded))
        return;

    cProcesses = cbNeeded / sizeof(DWORD);

    // Get hash and compare to signatures
    for (int i = 0; i < cProcesses; i++) {
        if (aProcesses[i] != 0)
            CheckProcess(aProcesses[i]);
    }
}